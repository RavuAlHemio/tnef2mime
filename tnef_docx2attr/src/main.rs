use std::borrow::Cow;
use std::collections::HashMap;
use std::env;
use std::ffi::OsString;
use std::path::PathBuf;

use docx2attr_common::{docx_to_paragraphs, byte_string_to_le_int_string};
use once_cell::sync::Lazy;
use regex::Regex;


static CONST_DEF_RE: Lazy<Regex> = Lazy::new(|| Regex::new(concat!(
    "^",
    "\\s*",
    "(?P<name>\\S+)",
    "\\s*",
    "=",
    "\\s*",
    "%x",
    "(?P<bytes>",
        "[0-9a-fA-F]{2}",
        "(?:",
            "\\.",
            "[0-9a-fA-F]{2}",
        ")*",
    ")",
    "\\s*",
    "$",
)).unwrap());


fn is_constant_definition(s: &String) -> bool {
    CONST_DEF_RE.is_match(s)
}


fn run() -> i32 {
    let enums = [
        ("TnefAttributeLevel", "attrLevel", "u8"),
        ("TnefAttributeId", "id", "u32"),
    ];

    let args: Vec<OsString> = env::args_os().collect();
    if args.len() != 2 {
        let prog_name = args.get(0)
            .map(|a| a.to_string_lossy())
            .unwrap_or(Cow::Borrowed("tnef_docx2attr"));
        eprintln!("Usage: {} MS-OXTNEF.DOCX", prog_name);
        return 1;
    }

    let docx_path = PathBuf::from(&args[1]);
    let paragraphs = docx_to_paragraphs(
        &docx_path,
        is_constant_definition,
    );

    let mut name_to_variants: HashMap<&str, Vec<String>> = HashMap::new();
    for (name, _prefix, _repr) in &enums {
        name_to_variants.insert(*name, Vec::new());
    }

    for paragraph in &paragraphs {
        let caps = CONST_DEF_RE.captures(paragraph)
            .expect("predicate failed");
        let name = caps.name("name").unwrap().as_str();
        let bytes_str = caps.name("bytes").unwrap().as_str();
        let bytes_int = byte_string_to_le_int_string(bytes_str);

        for (enum_name, prefix, _repr) in &enums {
            if let Some(variant) = name.strip_prefix(prefix) {
                name_to_variants
                    .get_mut(enum_name).unwrap()
                    .push(format!("    {} = 0x{},", variant, bytes_int));
            }
        }
    }

    println!("// This file has been generated by tnef_docx2attr.");
    println!();
    println!("use from_to_repr::from_to_other;");
    println!();
    println!();

    let mut first = true;
    for (enum_name, _prefix, repr) in &enums {
        if first {
            first = false;
        } else {
            println!();
        }

        println!("#[derive(Clone, Copy, Debug)]");
        println!("#[from_to_other(base_type = {}, derive_compare = \"as_int\")]", repr);
        println!("pub enum {} {{", enum_name);
        for variant in name_to_variants.get(enum_name).unwrap().iter() {
            println!("{}", variant);
        }
        println!("    Other({}),", repr);
        println!("}}");
    }

    0
}


fn main() {
    std::process::exit(run());
}
